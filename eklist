#!/usr/bin/python3

import sys
import struct
import mmap

import echolab2.instruments.util.simrad_parsers as sp
import echolab2.instruments.util.simrad_raw_file as raw

import actions as act

def parse(str):
    # duplicates the simrad_raw_file.DGRAM_TYPE_KEY, but with bytestring keys
    parsers = {
          b'BOT' : sp.SimradBottomParser()
        , b'CON' : sp.SimradConfigParser()
        , b'DEP' : sp.SimradDepthParser()
        , b'FIL' : sp.SimradFILParser()
        , b'MRU' : sp.SimradMRUParser()
        , b'NME' : sp.SimradNMEAParser()
        , b'RAW' : sp.SimradRawParser()
        , b'TAG' : sp.SimradAnnotationParser()
        , b'XML' : sp.SimradXMLParser()
    }

    dgram_type = str[:3]
    p = parsers[dgram_type]
    return(p.from_string(str, len(str)))

def process(f, verbose=False, filters=[], actions=[]):
    with open(f, "rb") as fh:
        print(f)
        with mmap.mmap(fh.fileno(), length=0, access=mmap.ACCESS_READ) as mf:
            pos = 0
            count = 0
            while pos < len(mf):
                l, m = struct.unpack('<l4s', mf[pos:pos+8])
                if pos+l > len(mf):
                    raise Exception('Premature EOF, truncated RAW file?')
                v = struct.unpack('<l', mf[pos+l+4:pos+l+8])
                t = m.decode('latin-1')
                if v[0]!=l: print(f'Warning: datagram {count}: control lenght mismatch ({l} vs {v[0]}) - endianness error or corrupt file?')
                if verbose:
                    print(f'Datagram {count}:\t{pos}\t{l}\t{t}')
                # if any filters, apply them
                obj = parse(mf[pos+4:pos+4+l])
                for a in actions:
                    a(obj)
                pos += l+8
                count += 1


for f in sys.argv[1:]:
    process(f, verbose=True, actions=[act.checkdate])
