#!/usr/bin/python3

import sys
import struct
import mmap

import echolab2.instruments.util.simrad_parsers as sp
import echolab2.instruments.util.simrad_raw_file as raw

import actions as act

def parse(str):
    '''Table for selecting the correct parser to use for datagrams'''
    # duplicates the simrad_raw_file.DGRAM_TYPE_KEY, but with bytestring keys
    parsers = {
          b'BOT' : sp.SimradBottomParser()
        , b'CON' : sp.SimradConfigParser()
        , b'DEP' : sp.SimradDepthParser()
        , b'FIL' : sp.SimradFILParser()
        , b'MRU' : sp.SimradMRUParser()
        , b'NME' : sp.SimradNMEAParser()
        , b'RAW' : sp.SimradRawParser()
        , b'TAG' : sp.SimradAnnotationParser()
        , b'XML' : sp.SimradXMLParser()
    }

    dgram_type = str[:3]
    p = parsers[dgram_type]
    return(p.from_string(str, len(str)))

def index(f):
    '''Build an index of datagrams in a Simrad RAW file'''
    idx = []
    with open(f, "rb") as fh:
        with mmap.mmap(fh.fileno(), length=0, access=mmap.ACCESS_READ) as mf:
            pos = 0
            while pos < len(mf):
                l, m = struct.unpack('<l4s', mf[pos:pos+8])
                if pos+l > len(mf):
                    raise Exception('Premature EOF, truncated RAW file?')
                v = struct.unpack('<l', mf[pos+l+4:pos+l+8])
                t = m.decode('latin-1')
                if v[0]!=l: print(f'Warning: datagram at {pos}: control lenght mismatch ({l} vs {v[0]}) - endianness error or corrupt file?')
                idx.append((pos,t,l,mf[pos+4:pos+4+l]))
                pos += l+8
    return idx

def process(df, verbose=False, filters=[], actions=[]):
    '''Process an indexed Simrad RAW file by applying a set of actions'''
    count = 0
    for pos, t, l, bstr in df:
        if verbose:
            print(f'Datagram {count}:\t{pos}\t{l}\t{t}')
        count += 1
        if actions:
            if not filters or any(f(pos,t,l) for f in filters):
                obj = parse(bstr)
                for a in actions:
                    a(obj)
    # signal end
    for a in actions:
        a(None)

if __name__ == '__main__':

    import argparse

    p = argparse.ArgumentParser(description='Extract information from Simrad RAW files.')
    p.add_argument('-t', '--type',  default=[], action='append', help='only apply to given datagram types')
    p.add_argument('-l', '--list',  action='store_true', help='output datagram contents extensively')
    p.add_argument('-s', '--summarize', action='store_true', help='summarize datagrams')
    p.add_argument('-q', '--quiet', action='store_true', help='produce minimal output')
    p.add_argument('-c', '--check', action='store_true', help='check datagram contents for consistency')
    p.add_argument('FILE', nargs='+', help='input files in RAW format.')
    args = p.parse_args()
    
    actions = []
    if args.check: actions.append(act.checkdate)
    if args.summarize: actions.append(act.summarize())
    if args.list:
        if args.quiet:
            error('Please specify at most one of -l and -q')
            exit -1
        else:
            actions.append(act.showdict)

    fs = []
    if args.type: fs.append(act.filtertype(args.type))
    
    for f in args.FILE:
        # print(f)
        d = index(f)
        process(d, verbose=not args.quiet, actions=actions, filters=fs)
