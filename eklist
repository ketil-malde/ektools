#!/usr/bin/python3

import sys
import struct
import mmap

import echolab2.instruments.util.simrad_parsers as sp
import echolab2.instruments.util.simrad_raw_file as raw

import actions as act

def parse(str):
    '''Table for selecting the correct parser to use for datagrams'''
    # duplicates the simrad_raw_file.DGRAM_TYPE_KEY, but with bytestring keys
    parsers = {
          b'BOT' : sp.SimradBottomParser()
        , b'CON' : sp.SimradConfigParser()
        , b'DEP' : sp.SimradDepthParser()
        , b'FIL' : sp.SimradFILParser()
        , b'MRU' : sp.SimradMRUParser()
        , b'NME' : sp.SimradNMEAParser()
        , b'RAW' : sp.SimradRawParser()
        , b'TAG' : sp.SimradAnnotationParser()
        , b'XML' : sp.SimradXMLParser()
    }

    dgram_type = str[:3]
    p = parsers[dgram_type]
    return(p.from_string(str, len(str)))

def index(f):
    '''Build an index of datagrams in a Simrad RAW file'''
    idx = []
    with open(f, "rb") as fh:
        with mmap.mmap(fh.fileno(), length=0, access=mmap.ACCESS_READ) as mf:
            pos = 0
            while pos < len(mf):
                l, m = struct.unpack('<l4s', mf[pos:pos+8])
                if pos+l > len(mf):
                    raise Exception('Premature EOF, truncated RAW file?')
                v = struct.unpack('<l', mf[pos+l+4:pos+l+8])
                t = m.decode('latin-1')
                if v[0]!=l: print(f'Warning: datagram at {pos}: control lenght mismatch ({l} vs {v[0]}) - endianness error or corrupt file?')
                idx.append((pos,t,l,mf[pos+4:pos+4+l]))
                pos += l+8
    return idx

def process(df, verbose=False, filters=[], actions=[]):
    '''Process an indexed Simrad RAW file by applying a set of actions'''
    count = 0
    for pos, t, l, bstr in df:
        if verbose:
            print(f'Datagram {count}:\t{pos}\t{l}\t{t}')
        count += 1
        # if any filters, apply them
        obj = parse(bstr)
        for a in actions:
            a(obj)


for f in sys.argv[1:]:
    d = index(f)
    process(d, verbose=True, actions=[act.checkdate])
